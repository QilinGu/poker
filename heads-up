#!/usr/bin/env python

from __future__ import division
import re
import sys
import optparse
from numpy import *
from nash import *
from util import *
from fractions import *

usage = "usage: %prog [options...] [args...]"
parser = optparse.OptionParser(usage)
parser.add_option('-b','--bet',type=str,default=0,help='set a fixed bet level')
parser.add_option('--plot',action='store_true',help="plot Alice's equity for bets in [0,bet]")
parser.add_option('--max',action='store_true',help="maximize Alice's equity as a function of bet in [0,bet]")
parser.add_option('-n',type=int,default=10,help="number of samples to plot")
options,args = parser.parse_args()
if len(args): parser.error('zero arguments expected')

cards = '23456789TJQKA'
nonpairs = [cards[i]+cards[j] for i in xrange(len(cards)) for j in xrange(i)]
hands = [c+c for c in cards]+[h+'s' for h in nonpairs]+[h+'o' for h in nonpairs]
assert len(hands)==13+13*12
hand_id = dict((h,i) for (i,h) in enumerate(hands))

def die(s):
    print>>sys.stderr, s
    sys.exit(1)

# Load exact win probabilities.  Important: win[a,b]+win[b,a]<1 due to ties, unlike the approximate version above
def parse_exact_matchups():
    matchup_pattern = re.compile(r'^(\w+)\s+vs\.\s+(\w+):$')
    entry_pattern = re.compile(r'^\s+(Alice|Bob|Tie):\s+(\d+/\d+) = ([\d.]+)$')
    lines = open('exact.txt').readlines()
    assert len(lines)%4==0
    win = zeros((len(hands),)*2,dtype=object)
    for i in xrange(len(lines)//4):
        m = matchup_pattern.match(lines[4*i])
        if not m: die('Weird matchup line: %s'%lines[4*i][:-1])
        h0,h1 = hand_id[m.group(1)],hand_id[m.group(2)]
        def entry(j,name):
            m = entry_pattern.match(lines[4*i+j+1])
            if not m: die('Weird entry line: %s'%lines[4*i+j+1][:-1])
            assert m.group(1)==name
            return Fraction(m.group(2))
        w,l,t= entry(0,'Alice'),entry(1,'Bob'),entry(2,'Tie')
        assert w+l+t==1
        win[h0,h1] = w
        win[h1,h0] = l
    assert all(win>0)
    return win
exact_win = parse_exact_matchups()

def lcm(x,y):
    return x*y/gcd(x,y)

print 'denominator = %d'%reduce(lcm,(f.denominator for f in exact_win.ravel()))

# Build a map from pairs of cards (represented as 4*id+suit) to hand ids
def compute_cards_to_hand():
    suits = xrange(4)
    cards_to_hand = -ones((4*len(cards),)*2,dtype=int)
    for c0 in xrange(len(cards)):
        h = hand_id[cards[c0]*2]
        for s0 in suits:
            for s1 in suits:
                if s0!=s1:
                    cards_to_hand[4*c0+s0,4*c0+s1] = h
        for c1 in xrange(c0):
            h = cards[c0]+cards[c1]
            hs = hand_id[h+'s']
            ho = hand_id[h+'o']
            for s0 in suits:
                cs0 = 4*c0+s0
                for s1 in suits:
                    cs1 = 4*c1+s1
                    cards_to_hand[cs0,cs1] = cards_to_hand[cs1,cs0] = hs if s0==s1 else ho
    return cards_to_hand
cards_to_hand = compute_cards_to_hand()
assert sum(cards_to_hand<0)==52

def hand_probabilities():
    # Count how many times h occurs in cards_to_hand for each h
    def prob(x):
        prob = zeros(len(hands),object)
        for h in xrange(len(hands)):
            prob[h] = sum(x==h)
        return fractions(prob)/Fraction(sum(prob))
    hand_prob = prob(cards_to_hand)

    i = xrange(len(cards_to_hand))
    hand_to_cards = dict((cards_to_hand[c,d],(c,d)) for c in i for d in i)

    # Compute conditional probabilities of each hand given each other hand
    cond_hand_prob = zeros((len(hands),)*2,object)
    for h in xrange(len(hands)):
        cs = hand_to_cards[h]
        remaining = array([i for i in xrange(13*4) if i not in cs])
        cond_hand_prob[h] = prob(cards_to_hand[remaining.reshape(-1,1),remaining.reshape(1,-1)])
    return hand_prob,cond_hand_prob
exact_hand_prob,exact_cond_hand_prob = hand_probabilities()
exact_hand_hand_prob = exact_hand_prob.reshape(-1,1)*exact_cond_hand_prob
assert sum(exact_hand_hand_prob)==1
assert all(exact_hand_hand_prob==exact_hand_hand_prob.T)

# Check all interesting conditional probabilities
F = Fraction
assert exact_hand_prob[hand_id['AA']]==F(1)/13*3/51
assert exact_hand_prob[hand_id['AKs']]==F(2)/13/51
assert exact_hand_prob[hand_id['AKo']]==F(2)/13*3/51
assert exact_cond_hand_prob[hand_id['AA'],hand_id['AA']]==F(2)/50*1/49
assert exact_cond_hand_prob[hand_id['AA'],hand_id['KK']]==F(4)/50*3/49
assert exact_cond_hand_prob[hand_id['AA'],hand_id['AKs']]==F(2)*2/50/49
assert exact_cond_hand_prob[hand_id['AA'],hand_id['AKo']]==F(2)*2/50*3/49
assert exact_cond_hand_prob[hand_id['AA'],hand_id['KQs']]==F(2)*4/50/49
assert exact_cond_hand_prob[hand_id['AA'],hand_id['KQo']]==F(2)*4/50*3/49
assert exact_cond_hand_prob[hand_id['AKs'],hand_id['AKs']]==F(2)*3/50/49
assert exact_cond_hand_prob[hand_id['AKs'],hand_id['AKo']]==F(2)*3/50*2/49
assert exact_cond_hand_prob[hand_id['AKs'],hand_id['AQs']]==F(2)*3/50/49
assert exact_cond_hand_prob[hand_id['AKs'],hand_id['AQo']]==F(2)*3/50*3/49
assert exact_cond_hand_prob[hand_id['AKs'],hand_id['QJs']]==F(2)*4/50/49
assert exact_cond_hand_prob[hand_id['AKs'],hand_id['QJo']]==F(2)*4/50*3/49
assert exact_cond_hand_prob[hand_id['AKo'],hand_id['AKo']]==F(2)/50*3/49+F(2)*2/50*2/49
assert exact_cond_hand_prob[hand_id['AKo'],hand_id['AQo']]==F(2)*3/50*3/49
assert exact_cond_hand_prob[hand_id['AKo'],hand_id['QJo']]==F(2)*4/50*3/49

# Approximate
approx_win = exact_win.astype(float)
approx_hand_prob = exact_hand_prob.astype(float)
approx_hand_hand_prob = exact_hand_hand_prob.astype(float)
approx_cond_hand_prob = exact_cond_hand_prob.astype(float)

# Switch to deterministic outcomes
if 0:
    outcome = dot(win,hand_prob)
    win[...] = outcome.reshape(-1,1)>outcome.reshape(1,-1)
    i = arange(len(outcome))
    win[i,i] = .5
    assert all(0<=win) and all(win<=1)
    assert all(abs(win+win.T-1)<=1e-10)
    rank = sorted(i,key=lambda i:outcome[i])
    print 'hand rank = %s'%(' '.join(hands[i] for i in rank))

def if_(c,a,b):
    return c*a+(1-c)*b # Use multiplication in order to work for all probabilities in [0,1]

def check_payoff(bet,alice,bob,exact=True):
    if exact:
        hand_hand_prob,win = exact_hand_hand_prob,exact_win
    else:
        bet = float(bet)
        hand_hand_prob,win = approx_hand_hand_prob,approx_win
    return sum(hand_hand_prob*alice.reshape(-1,1)*if_(bob.reshape(1,-1),(1+bet)*(win-win.T),1))

def alice_payoff(bet,bob,exact=True):
    "Alice's expected return from calling with each possible hand"
    if exact:
        cond_hand_prob,win = exact_cond_hand_prob,exact_win
    else:
        bet = float(bet)
        cond_hand_prob,win = approx_cond_hand_prob,approx_win
    return sum(cond_hand_prob*if_(bob.reshape(1,-1),(1+bet)*(win-win.T),1), axis=1)

def bob_payoff(bet,alice,exact=True):
    "Bob's expected return from calling with each possible hand"
    if exact:
        hand_hand_prob,win = exact_hand_hand_prob,exact_win
    else:
        bet = float(bet)
        hand_hand_prob,win = approx_hand_hand_prob,approx_win
    hand_hand_call_prob = alice.reshape(1,-1)*hand_hand_prob
    inv_cond_hand_prob = hand_hand_call_prob / hand_hand_call_prob.sum(axis=1).reshape(-1,1)
    return sum(inv_cond_hand_prob*(1+(1+bet)*(win-win.T)), axis=1)

def always_call():
    alice = ones(len(hands),dtype=int)
    bob = ones(len(hands),dtype=int)
    return alice,bob

def ahash(*args):
    return hash(''.join(a.tostring() for a in args))

# Converge to heads up Nash equilibrium from an initial strategy guess
def poker_nash_equilibrium(bet,(alice,bob)=always_call(),n=1000,verbose=1):
    alice = alice.astype(bool)
    bob = bob.astype(bool)
    bounds = [-inf,inf]
    # Iterate until we detect looping
    hashes = set()
    looping = False
    strategies = []
    while 1:
        done = 1
        if verbose:
            print 'equity range = %g %g'%(bounds[0],bounds[1])
        # Make at most one change to Alice's strategy
        payoff = alice_payoff(bet,bob,exact=0)
        bounds[1] = min(bounds[1],dot(approx_hand_prob,maximum(0,payoff))) # Bob can hold Alice to below this
        error = payoff*((payoff>0)*(1-alice) - (payoff<0)*alice)
        h = argmax(error)
        if error[h]:
            alice = alice.copy()
            alice[h] = 1-alice[h]
            if verbose:
                print 'Alice should%s call with %s'%(('' if alice[h] else "n't"),hands[h])
            done = 0
        # Make at most one change to Bob's strategy
        payoff = bob_payoff(bet,alice,exact=0)
        error = payoff*((payoff>0)*(1-bob) - (payoff<0)*bob)
        bounds[0] = max(bounds[0],check_payoff(bet,alice,payoff>0,exact=0)) # Alice can hold Bob to above this
        h = argmax(error)
        if error[h]:
            bob = bob.copy()
            bob[h] = 1-bob[h]
            if verbose:
                print 'Bob should%s call with %s'%(('' if bob[h] else "n't"),hands[h])
            done = 0
        # Are we done?
        if done:
            strategies = [(alice,bob)]
            break
        ah = ahash(alice,bob)
        if verbose:
            print 'hash = %s'%ah
        if ah in hashes:
            if looping:
                break
            else:
                hashes = set()
            looping = True
        if looping:
            strategies.append((alice,bob))
        hashes.add(ah)
    # Print strategies
    print '\nfinal equity range = %g %g'%(bounds[0],bounds[1])
    for k,name in enumerate(['Alice','Bob']):
        print '%s has %d %s:'%(name,len(strategies),'strategy' if len(strategies)==1 else 'strategies')
        for s in strategies:
            call = s[k]
            print '  %d hands: %s'%(sum(call),' '.join(hands[i] for i in nonzero(call)[0]))
    # Compute exact Nash equilibrium matrix
    alices = [s[0] for s in strategies]
    bobs = [s[1] for s in strategies]
    while 1:
        # Compute Nash equilibrium ranging over our current list of Alice's and Bob's strategies
        print 'computing payoffs...'
        payoff = empty((len(alices),len(bobs)),object)
        for a,alice in enumerate(alices):
            for b,bob in enumerate(bobs):
                payoff[a,b] = check_payoff(bet,alice,bob,exact=1)
        print 'computing payoffs...done'
        nash,alice,bob = zero_sum_nash_equilibrium(payoff)
        alice = sum(a*s for a,s in zip(alice,alices))
        bob = sum(b*s for b,s in zip(bob,bobs))
        # Determine Alice's and Bob's new optimal strategies, and add them to our lists if necessary
        done = 1
        opt_alice = alice_payoff(bet,bob)>0
        if ahash(opt_alice) not in map(ahash,alices):
            alices.append(opt_alice)
            done = 0
        opt_bob = bob_payoff(bet,alice)>0
        if ahash(opt_bob) not in map(ahash,bobs):
            bobs.append(opt_bob)
            done = 0
        if done:
            break
    # Verify that we've found the Nash equilibrium
    equity = check_payoff(bet,alice,bob)
    assert equity==nash
    assert bounds[0]-1e10<=equity<=bounds[1]+1e10
    if 0:
        print 'first error = %g'%(check_payoff(bet,alice,bob_payoff(bet,alice)>0)-equity)
        print 'second error = %g'%(check_payoff(bet,alice_payoff(bet,bob)>0,bob)-equity)
    assert equity==check_payoff(bet,alice,bob_payoff(bet,alice)>0)
    assert equity==check_payoff(bet,alice_payoff(bet,bob)>0,bob)
    # Print out nice results
    if verbose:
        def str_strategy(strat,payoff):
            order = sorted(arange(len(strat)),key=lambda i:-payoff[i])
            return ' '.join(('' if strat[i]==1 else '%s*'%strat[i])+hands[i] for i in order if strat[i])
        print
        print 'Alice: %d hands, %s'%(sum(alice>0),str_strategy(alice,alice_payoff(bet,bob)))
        print 'Bob: %d hands, %s'%(sum(bob>0),str_strategy(bob,bob_payoff(bet,alice)))
    return equity,alice,bob

def poker_nash_equilibrium_remember(bet,last=list(always_call())):
    equity,alice,bob = poker_nash_equilibrium(bet,last)
    last[:] = round_(alice),round_(bob)
    return equity

bet = options.bet
try:
    bet = Fraction(bet)
except TypeError:
    bet = float(bet) 

if options.plot:
    n = arange(options.n)
    bet = bet/n[-1]*n
    print 'bets = %s'%bet
    s = list(always_call())
    def nash(b):
        e,alice,bob = poker_nash_equilibrium(b,s,verbose=1)
        s[:] = round_(alice),round_(bob)
        return e
    equity = array(map(poker_nash_equilibrium_remember,bet))
    import pylab
    pylab.plot(bet,equity)
    pylab.xlabel('bet')
    pylab.ylabel("Alice's equity")
    pylab.title("Alice's equity as a function of fixed bet size")
    pylab.show()
elif options.max:
    import scipy.optimize
    bet,equity,_,evals = scipy.optimize.fminbound(lambda b:-poker_nash_equilibrium_remember(b),0,bet,full_output=1,xtol=1e-8)
    print "\nAlice's preferred bet = %g"%bet
    print "Alice's equity = %g"%-equity
    print "Nash equilibrium computations = %d"%evals
else:
    equity,alice,bob = poker_nash_equilibrium(bet)
    print "Alice's exact payoff = %s (%g)"%(equity,equity)

